float rayHitSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius) {
    vec3 oc = rayOrigin - sphereCenter;
    float b = dot(oc, rayDir);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    
    // The discriminant tells us if the quadratic equation has real roots.
    // A positive discriminant means the ray intersects the sphere.
    float discriminant = b * b - c;

    if (discriminant < 0.0) {
        return -1.0; 
    }
    return -b - sqrt(discriminant);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;

    // 1. Setup the orbiting light source
    float orbitRadius = 1.2;
    float lightSpeed = iTime * 2.0;
    vec3 lightCenter = vec3(orbitRadius * cos(lightSpeed), orbitRadius * sin(lightSpeed), 1.0);
    float lightRadius = 0.15;

    // Check if the camera viewing ray directly hits the light source
    vec3 viewRayOrigin = vec3(uv, 5.0);
    vec3 viewRayDir = vec3(0.0, 0.0, -1.0);
    float hitLightDirect = rayHitSphere(viewRayOrigin, viewRayDir, lightCenter, lightRadius);

    // 2. Create the main sphere area
    float dist = length(uv);
    if (dist < 0.5) {
        
        // Reconstruct the 3D surface point of the main sphere
        float z = sqrt(0.25 - dist * dist);
        vec3 surfacePoint = vec3(uv, z);
       
        // Setup directions
        vec3 normal = normalize(surfacePoint);
        vec3 lightDir = normalize(lightCenter - surfacePoint); 
        vec3 viewDir = vec3(0.0, 0.0, 1.0);
       
        // A. The Diffuse (Matte)
        float diffuse = max(dot(normal, lightDir), 0.0);
       
        // B. The Specular (Physically Based Ray-Casting)
        // Specular reflection is the mirror-like reflection of light from a surface.
        vec3 reflectDir = reflect(-viewDir, normal);
        
        // Offset the ray origin slightly along the normal to prevent self-intersection.
        vec3 rayOrigin = surfacePoint + normal * 0.001;
        
        // Ray-casting projects a line in 3D space to test for object collisions.
        float hitDist = rayHitSphere(rayOrigin, reflectDir, lightCenter, lightRadius);
        
        float specular = 0.0;
        if (hitDist > 0.0) {
            specular = 1.0; 
        }
       
        // C. Combine them
        vec3 baseColor = vec3(0.1, 0.4, 0.8); 
        vec3 finalOutput = (baseColor * diffuse) + (vec3(1.0) * specular);
       
        fragColor = vec4(finalOutput, 1.0);
        
    } else if (hitLightDirect > 0.0) {
        // Draw the white light source sphere
        fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    } else {
        fragColor = vec4(0.1, 0.1, 0.1, 1.0); 
    }
}